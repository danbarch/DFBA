}
t.test
body(t.test)
getAnywhere(t.test)
debug(t.test)
methods(t.test)
?methods
methods(class="t.test")
methods(summary)
methods(class="aov")
Beta_intervalBayesfactor<-function(n1,n2,lowerH0value=0,upperH0value=.5,a0=1,b0=1){
if ((lowerH0value<0)|(lowerH0value>1)|(lowerH0value>=upperH0value)|(upperH0value>1)) {lowerH0value=0
upperH0value=.5} else {}
#  print("H0 range is:")
rangeH0<-c(lowerH0value,upperH0value)
#  print(rangeH0)
if ((a0<=0)|(b0<=0)) {
a0=1
b0=1} else {}
if ((n1<0)|(n2<0)){
stop("Error. Both n1 and n2 must be nonnegative; please redo")} else {
a=n1+a0
b=n2+b0
pH0up=pbeta(upperH0value,a0,b0)
pH0lo=pbeta(lowerH0value,a0,b0)
pH0=pH0up-pH0lo
pH1=1-pH0
#      print("prior probability for H0 is:")
#      print(pH0)
#      print("prior probability for H1 is:")
#      print(pH1)
postH0up=pbeta(upperH0value,a,b)
postH0lo=pbeta(lowerH0value,a,b)
postH0=postH0up-postH0lo
#      print("posterior probability for H0 is")
#      print(postH0)
postH1=1-postH0
#      print("posterior probability for H1 is:")
#      print(postH1)
if (pH0>=postH0){
Direction<-"Bayes factor is for alternative over null"
#        print("Bayes factor is for alternative over null")
if(postH0==0) {print("BF10 approaches infinity")} else
{BF10=((1/postH0)-1)/((1/pH0)-1)
#        print(BF10)
BF<-BF10}} else {
Direction<-"Bayes factor is for null over alternative"
#          print("Bayes factor is for null over alternative")
if (postH0==1){print("BF01 is near infinity")} else
{BF01=((1/pH0)-1)/((1/postH0)-1)
#          print(BF01)
BF<-BF01}}
}
list(H0_Range=rangeH0,
H0_prior=pH0,
H1_prior=pH1,
H0_posterior=postH0,
h1_posterior=postH1,
Direction=Direction,
BF=BF
)
}
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
rval<-Phi(x, y, a.prior, b.prior, hdi.width)
class(rval)<-"htest"
return(rval)
}
x
x<-c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5)
y<-c(1, 1, 4, 4, 5, 1, 2, 3, 5, 1, 2, 3, 3, 3, 3, 5, 2, 4, 4, 4, 5, 5, 3, 4, 4, 5, 5)
Gamma_Concordance(x, y)
# Concordance Parameter Phi
#
# Concordance Parameter Phi
#
# Concordance Parameter Phi
#
Phi<-function(x, y, a.prior=1, b.prior=1, hdi.width=0.95){
xy<-data.frame(x,y)                               #append x and y vectors
t_xi<-unname(table(x)[table(x)>1])                #Counting T_x sizes of ties
t_yi<-unname(table(y)[table(y)>1])                #Counting T_y sizes of ties
Tx<-sum((t_xi*(t_xi-1))/2)                        #Calculating Tx
Ty<-sum((t_yi*(t_yi-1))/2)                        #Calculating Ty
t_xyi<-unname(table(xy)[table(xy)>1])             #Calculating txyi
Txy<-sum(t_xyi*(t_xyi-1)/2)                       #Calculating Txy
n<-length(x)
n_max<-n*(n-1)/2-Tx-Ty+Txy
xy_ranks<-data.frame(xrank=rank(xy$x, ties.method="average"),
yrank=rank(xy$y, ties.method="average"))
xy_c<-xy_ranks[order(x, -y),]       # for n_c, sort on ascending x then descending y
xy$concordant<-rep(NA, nrow(xy))
for (i in 1:nrow(xy-1)){
xy$concordant[i]<-sum(xy_c$yrank[(i+1):length(xy_c$yrank)]>xy_c$yrank[i])
}
nc<-sum(xy$concordant, na.rm=TRUE)
nd<-n_max-nc
Tau<-(nc-nd)/n_max
p_c<-(Tau+1)/2
a.post<-a.prior+nc
b.post<-b.prior+nd
post.median<-qbeta(0.5, a.post, b.post)
post.hdi.lower<-qbeta((1-hdi.width)/2, a.post, b.post)
post.hdi.upper<-qbeta(1-(1-hdi.width)/2, a.post, b.post)
list(tau=Tau,
sample.p=p_c,
alpha=a.post,
beta=b.post,
post.median=post.median,
post.hdi.lower=post.hdi.lower,
post.hdi.upper=post.hdi.upper)
}
Gamma_Concordance(x, y)
rval
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
rval<-Phi(x, y, a.prior, b.prior, hdi.width)
#  class(rval)<-"htest"
return(rval)
}
Gamma_Concordance(x, y)
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
rval<-Phi(x, y, a.prior, b.prior, hdi.width)
names(rval$tau<-"gamma")
return(rval)
}
Gamma_Concordance(x, y)
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
rval<-Phi(x, y, a.prior, b.prior, hdi.width)
names(rval$tau)<-"gamma"
return(rval)
}
Gamma_Concordance(x, y)
gamma<-Phi(x, y, a.prior, b.prior, hdi.width)$tau
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
gamma<-Phi(x, y, a.prior, b.prior, hdi.width)$tau
list(gamma=gamma)
}
Gamma_Concordance(x, y)
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
gamma<-
list(gamma=Phi(x, y, a.prior, b.prior, hdi.width)$tau,
Phi(x, y, a.prior, b.prior, hdi.width)[-1])
}
Gamma_Concordance(x, y)
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
list(gamma=Phi(x, y, a.prior, b.prior, hdi.width)$tau,
Phi(x, y, a.prior, b.prior, hdi.width)[-1])
}
Gamma_Concordance(x, y)
Gamma_Concordance<-function(x, y=NULL, a.prior=1, b.prior=1, hdi.width=0.95){
if(is.matrix(x)==TRUE){
table<-x
x<-Table_to_vec(table)$x
y<-Table_to_vec(table)$y
}
list(gamma=Phi(x, y, a.prior, b.prior, hdi.width)$tau,
sample.p=Phi(x, y, a.prior, b.prior, hdi.width)$sample.p,
alpha=Phi(x, y, a.prior, b.prior, hdi.width)$alpha,
beta=Phi(x, y, a.prior, b.prior, hdi.width)$beta,
post.median=Phi(x, y, a.prior, b.prior, hdi.width)$post.median,
post.hdi.lower=Phi(x, y, a.prior, b.prior, hdi.width)$post.hdi.lower,
post.hdi.upper=Phi(x, y, a.prior, b.prior, hdi.width)$post.hdi.upper)
}
Gamma_Concordance(x, y)
t.test(1, 2, 3, 4, 5)
t.test(2)
t.test(c(1, 2, 3, 4, 5))
q
q
q
q
q
t.test(c(1,2,3,4,5))
Q
undebug(t.test)
t.test(c(1,2,3,4,5))
1051+47
list(x=1, y=2)
cat(list(x=1, y=2))
cat(x=1, y=2)
wts<-c(1/3,1/3,1/3,-.5,-.5)
n1v<-c(8,7,10,3,6)
n2v<-c(4,5,2,9,6)
priora0<-c(1,1,1,1,1)
priorb0<-c(1,1,1,1,1)
Beta_betweengroups<-function(wts, n1v, n2v, priora0, priorb0, N=10000){
if ((N!=round(N))|(N<0)){
stop("N must be a positive integer")
} else {N=N}
#  testfailed=0
l=length(wts)
ln1=length(n1v)
ln2=length(n2v)
la0=length(priora0)
lb0=length(priorb0)
if ((ln1!=l)|(ln2!=l)|(la0!=l)|(lb0!=l)){
#    testfailed=testfailed+1
stop("Error - the five vectors do not have the same length; must redo")
}
#else {testfailed=testfailed}
totalwt=sum(wts)
if (abs(totalwt)<=.001){
totalwt=0
} else {
#totalwt=totalwt} else {totalwt=0}
#  if (totalwt!=0) {testfailed=testfailed+1
stop("Error: the sum of the weight coeficients is not zero; must redo")
#  else {testfailed=testfailed}
}
n1count=0
for (I in 1:ln1){
if (n1v[I]<0){n1count=n1count+1} else {n1count=n1count}}
if (n1count>0){
#testfailed=testfailed+1
stop("Error. No component in n1v can be negative")
} else {
#testfailed=testfailed
}
n2count=0
for (I in 1:ln2){
if (n2v[I]<0){
n2count=n2count+1
} else {n2count=n2count}
}
if (n2count>0){
#testfailed=testfailed+1
stop("Error. No component in n2v can be negative")
} else {
#testfailed=testfailed
}
a0count=0
for (I in 1:la0){
if (priora0[I]<=0){
a0count=a0count+1
} else {a0count=a0count}
}
if (a0count>0){
#testfailed=testfailed+1
stop("Error. All components in priora0 must be positive values")
} else {
#testfailed=testfailed
}
b0count=0
for (I in 1:lb0){
if (priorb0[I]<=0){
b0count=b0count+1
} else {b0count=b0count}
}
if (b0count>0){
#testfailed=testfailed+1
stop("Error. All components in priorb0 must be positve values")
} else {
#testfailed=testfailed
}
#  print("The contrast weights are:")
#  print(wts)
a=n1v+priora0
b=n2v+priorb0
phimeans=(seq(1,l,1))*0
phivar=(seq(1,l,1))*0
for (I in 1:l){
phimeans[I]=a[I]/(a[I]+b[I])
phivar[I]=(phimeans[I]*(1-phimeans[I]))/(a[I]+b[I]+1)
}
contrastmean=0
contrastvar=0
for (I in 1:l){
contrastmean=contrastmean+(wts[I]*phimeans[I])
contrastvar=contrastvar+(wts[I]*wts[I]*phivar[I])
}
#    print("contrast mean is:")
#    print(contrastmean)
#    print("contrast variance is:")
#    print(contrastvar)
delta=(seq(1,N,1))*0
for (I in 1:N){
delta[I]=0
for (J in 1:l){
delta[I]=delta[I]+wts[J]*rbeta(1,a[J],b[J])
}
}
xtest=mean(delta)
ytest=var(delta)
#    print("mean of the contrast from sampling:")
#    print(xtest)
#    print("variance of the contrast from sampling:")
#    print(ytest)
qhigh=quantile(delta,prob=.975)
qlow=quantile(delta,prob=.025)
intervallimit<-c(qlow,qhigh)
#    print("approximate equal-tail 95% interval for the contrast is:")
#    print(intervallimit)
postpostive=(sum(delta>0))/N
#    print("posterior probability for a positive contrast from sampling is:")
#    print(postpostive)
deltaprior=(seq(1,N,1))*0
for (I in 1:N){
deltaprior[I]=0
for (J in 1:l){
deltaprior[I]=deltaprior[I]+wts[J]*rbeta(1,priora0[J],priorb0[J])}}
priorpos=(sum(deltaprior>0))/N
#    print("prior probability for a positive contrast from sampling is:")
#    print(priorpos)
if (priorpos==0){
priorpos=.5/N
} else {priorpos=priorpos}
if (postpostive==1){
postpostive=N/(N+1)
} else {postpostive=postpostive}
BF10=(postpostive*(1-priorpos))/(priorpos*(1-postpostive))
#    print("Bayes factor for a postive contrast from simuation is:")
#    print(BF10)
#    print("Bayes factor for a negative contrast from sampling is:")
#    print(1/BF10)
list(contrast_Weights=wts,
contrast_mean=contrastmean,
contrast_variance=contrastvar,
sampling_contrast_mean=xtest,
sampling_contrast_variance=ytest,
equal_tail_95=intervallimit,
posterior_of_positive=postpositive,
prior_of_positive=priorpos,
BF_positive_contrast=BF10,
BF_negative_contrast=1/BF10
)
}
Bayes_mediantest<-function(Y1,Y2,a0=1,b0=1){
Y<-c(Y1,Y2)
med=median(Y)
#  print("Overall median is:")
#  print(med)
l1=length(Y1)
l2=length(Y2)
A1above=0
A1below=0
for (I in 1:l1){
if (Y1[I]>med){
A1above=A1above+1
} else {A1below=A1below+1}
}
A2above=0
A2below=0
for (I in 1:l2){
if (Y2[I]>med){
A2above=A2above+1
} else {A2below=A2below+1}
}
#  print("Respective frequencies of Y1 and Y2 above the median are:")
#  abovefreq<-c(A1above, A2above)
#  print(abovefreq)
#  print("Respective frequencies of Y1 and Y2 at or below median are:")
#  belowfreq<-c(A1below,A2below)
#  print(belowfreq)
a=A1above+a0
b=A2above+b0
Y1baserate=l1/(l1+l2)
probY1hi=1-pbeta(Y1baserate,a,b)
#  Y2baserate=1-Y1baserate
#  print("Respective base rates for Y1 and Y2 responses are:")
#  Y2baserate=1-Y1baserate
#  baserate<-c(Y1baserate,Y2baserate)
#  print(baserate)
#  print("Following is the analysis of the responses above the median:")
probY2hi=1-pbeta(Y2baserate,b,a)
if (probY1hi>=probY2hi) {
prob<-probY1hi
#    print("Posterior probability that Y1 exceeds base rate is:")
Direction<-"Y1 exceeds base rate"
#    print(probY1hi)
postodds=probY1hi/(1-probY1hi)
priorY1hi=1-pbeta(Y1baserate,a0,b0)
priorodds=priorY1hi/(1-priorY1hi)
BF=postodds/priorodds
#    print("Prior probability that Y1 exceeds base rate is:")
#    print(priorY1hi)
prior<-priorY1hi
#    print("Bayes factor is:")
#    print(BF)
} else {
Direction<-"Y2 exceeds base rate"
prob<-probY2hi
#      print("Posterior probability that Y2 exceeds base rate is:")
#      print(probY2hi)
postodds=probY2hi/(1-probY2hi)
priorY2hi=1-pbeta(Y2baserate,b0,a0)
priorodds=priorY2hi/(1-priorY2hi)
BF=postodds/priorodds
#      print("Prior probability that Y2 exceeds base rate is:")
prior<-priorY2hi
#      print(priorY2hi)
#      print("Bayes factor is:")
#      print(BF)
}
list(Overall_median=med,
Y1_freq_above=A1above,
Y2_freq_above=A2above,
Y1_freq_below=A1below,
Y2_freq_below=A2below,
Y1_base_rate=Y1baserate,
Y2_base_rate=1-Y1baserate,
Direction=Direction,
Posterior_Probability=prob,
Prior_Probability=prior,
Bayes_Factor=BF
)
}
library(DFBA)
Beta_intervalBayesfactor<-function(n1,n2,lowerH0value=0,upperH0value=.5,a0=1,b0=1){
if ((lowerH0value<0)|(lowerH0value>1)|(lowerH0value>=upperH0value)|(upperH0value>1)) {lowerH0value=0
upperH0value=.5} else {}
#  print("H0 range is:")
rangeH0<-c(lowerH0value,upperH0value)
#  print(rangeH0)
if ((a0<=0)|(b0<=0)) {
a0=1
b0=1} else {}
if ((n1<0)|(n2<0)){
stop("Error. Both n1 and n2 must be nonnegative; please redo")} else {
a=n1+a0
b=n2+b0
pH0up=pbeta(upperH0value,a0,b0)
pH0lo=pbeta(lowerH0value,a0,b0)
pH0=pH0up-pH0lo
pH1=1-pH0
#      print("prior probability for H0 is:")
#      print(pH0)
#      print("prior probability for H1 is:")
#      print(pH1)
postH0up=pbeta(upperH0value,a,b)
postH0lo=pbeta(lowerH0value,a,b)
postH0=postH0up-postH0lo
#      print("posterior probability for H0 is")
#      print(postH0)
postH1=1-postH0
#      print("posterior probability for H1 is:")
#      print(postH1)
if (pH0>=postH0){
Direction<-"Bayes factor is for alternative over null"
#        print("Bayes factor is for alternative over null")
if(postH0==0) {print("BF10 approaches infinity")} else
{BF10=((1/postH0)-1)/((1/pH0)-1)
#        print(BF10)
BF<-BF10}} else {
Direction<-"Bayes factor is for null over alternative"
#          print("Bayes factor is for null over alternative")
if (postH0==1){print("BF01 is near infinity")} else
{BF01=((1/pH0)-1)/((1/postH0)-1)
#          print(BF01)
BF<-BF01}}
}
list(H0_Range=rangeH0,
H0_prior=pH0,
H1_prior=pH1,
H0_posterior=postH0,
h1_posterior=postH1,
Direction=Direction,
BF=BF
)
}
Beta_intervalBayesfactor(20, 20)
Beta_intervalBayesfactor(20, 20)$BF
t.test(c(1,2,3,4,5))
t.test(c(1,2,3,4,5))$statistic
t.test(c(1,2,3,4,5))$p.value
t.test(c(1,2,3,4,5))$statistic-t.test(c(5, 6, 7, 8))$statistic
t.test(c(1,2,3,4,5))$statistic-t.test(c(5, 6, 7, 8))$p.value
ls()
install.packages("devtools")
devtools::install_github("danbarch/dfba/DFBA")
debug()
t.test()
debug(t.test
)
t.test()
q
if ((hdiprob>1) |(hdiprob<0)) {hdiprob=.95} else {}
Beta_pointBayesfactor
Beta_pointBayesfactor
